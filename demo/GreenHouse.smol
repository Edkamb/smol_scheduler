abstract class Twin() end

/**
 *  Class PlantToWater; it represents the id of the plant to water
 *  This information is needed by the scheduler to send to signal to water
 *  @class PlantToWater
 */
class PlantToWater extends Twin (String plantId, Int pumpGpioPin, String pumpId)
end

/**
 *  Class Plant; represents a physical plant. It is initially retrieved by
 *  the asset model, but it can be reconfigured by the program model.
 *  Each plant is associated with a pot. The Pot contains the information
 *  about which plant contains
 *  @class Plant
 */
class Plant extends Twin (String plantId, Double idealMoisture, String plantType, String healthState)
    Double getNdvi()
        Double healthState = 0.0;
        List<Double> influxReturn = null;

        influxReturn = access(
            "from(bucket: \"GreenHouseDemo\")
                |> range(start: -30d)
                |> filter(fn: (r) => r[\"_measurement\"] == \"ast:plant\")
                |> filter(fn: (r) => r[\"_field\"] == \"ndvi\")
                |> filter(fn: (r) => r[\"plant_id\"] == %1)
                |> keep(columns: [\"_value\"])
                |> last()",
        INFLUXDB("config_local.yml"),
        this.plantId);

        if influxReturn != null then
            healthState = influxReturn.get(0);
        end
        
        return healthState;
    end

    Double getPotMoisture()
        Double moisture = 100.0;
        List<Double> influxReturn = null;

        influxReturn = access(
            "from(bucket: \"GreenHouseDemo\")
                |> range(start: -30d)
                |> filter(fn: (r) => r[\"_measurement\"] == \"ast:pot\")
                |> filter(fn: (r) => r[\"_field\"] == \"moisture\")
                |> filter(fn: (r) => r[\"plant_id\"] == %1)
                |> keep(columns: [\"_value\"])
                |> last()",
        INFLUXDB("config_local.yml"),
        this.plantId);
        
        if influxReturn != null then
            moisture = influxReturn.get(0);
        end

        return moisture;
    end
end

/**
 *  Class HealthState; represents the health state of a plant via ndvi.
 *  @class HealthState
 */
class HealthState extends Twin (String name, Double minNdvi, Double maxNdvi)
end

/**
 *  Class Pot; represents a physical pot. It is initially retrieved by
 *  the asset model, but it can be reconfigured by the program model.
 *  Each pot is associated with a moisture sensor.
 *  @class Pot
 */
class Pot extends Twin (String shelfFloor, String potPosition, String pumpId, String plantId) 
    // Return last moisture detection for the pot
    Double getMoisture()
        Double moisture = 0.0;
        List<Double> influxReturn = null;
        
        // uses list because influx queries return lists
        influxReturn = access(
            "from(bucket: \"GreenHouseDemo\")
                |> range(start: -30d)
                |> filter(fn: (r) => r[\"_measurement\"] == \"ast:pot\")
                |> filter(fn: (r) => r[\"_field\"] == \"moisture\")
                |> filter(fn: (r) => r[\"pot_position\"] == %2)
                |> filter(fn: (r) => r[\"shelf_floor\"] == %3)
                |> keep(columns: [\"_value\"])
                |> last()",
        INFLUXDB("config_local.yml"),
        this.potPosition,
        this.shelfFloor);

        if influxReturn != null then
            Int length = influxReturn.length();
            print(length);
            // get first value of list (list contains just one value)
            moisture = influxReturn.get(0);
        end
        
        return moisture;
    end
end

/**
 *  Class Shelf; represents a physical shelf. It is initially retrieved by
 *  the asset model, but it can be reconfigured by the program model.
 *  @class Shelf
 */
class Shelf extends Twin (String shelfFloor)
end

/**
 *  Class Pump; represents a physical pump. It is initially retrieved by
 *  the asset model, but it can be reconfigured by the program model.
 *  @class Pump
 */
class Pump extends Twin (Int pumpGpioPin, String pumpId)
end

/**
 *  Class GreeHouse; it represents the actual greenhouse; as it is a singleton
 *  it will not be retrieved by the asset model, but it will be created by the
 *  program model.
 *  @class GreenHouse
 */
class GreenHouse extends Twin ()
    // get last light measurement for the greenhouse
    Double getLight()
        Double light = null;
        List<Double> influxReturn = null;

        // get light measurement from influx
        influxReturn = access(
            "from(bucket: \"greenhouse\")
                |> range(start: -30d)
                |> filter(fn: (r) => r[\"_measurement\"] == \"ast:greenhouse\")
                |> filter(fn: (r) => r[\"_field\"] == \"light\")
                |> keep(columns: [\"_value\"])
                |> last()",
            INFLUXDB("config_local.yml"));
        
        if influxReturn != null then
            light = influxReturn.get(0);
        end
        
        return light;
    end
end

class PumpDefect (Pump obj, Int pumpGpioPinNew) end
class PlantDefect (Plant obj, Double idealMoistureNew, String plantTypeNew) end
class PotDefectShelf (Pot obj, String shelfFloorNew) end
class PotDefectPosition (Pot obj, String potPositionNew) end
class PotDefectPump (Pot obj, String pumpIdNew) end
class PotDefectPlant (Pot obj, String plantIdNew) end

/**
 *  Asset model class; it will create the model based on the asset model
 *  as well as dealing with reconfiguration in case of a change in the
 *  program model.
 *  @class AssetModel
 */
class AssetModel extends Twin (List<PlantToWater> plantsToWater)
    /**
     *  Method to remove the WaterToPlant that was previously created
     *
     *  @method removePlantToWater
     */
    Unit removePlantToWater()
        List<PlantToWater> plantToWaters = this.plantsToWater;

        if plantToWaters != null then
            Int plantToWatersLength = plantToWaters.length();
            Int i = 0;
            while i < plantToWatersLength do
                PlantToWater plantToWater = plantToWaters.get(i);
                destroy(plantToWater);
                i = i + 1;
            end
        end
    end

    /**
     *  Method invoke the reconfigure the pumps. It will add pumps that are not
     *  in the program model and destroy pumps that are not in the asset model.
     *
     *  @method reconfigurePumps
     */
    Unit reconfigurePump()
        print("RECONFIG> Reconfiguring the pumps");
        Int i = 0;

        /**
         *  Add pumps that are not in the program model
         */
        List<Pump> newPumps = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT ?pumpGpioPin ?pumpId ?plantId
            WHERE {
                ?pump rdf:type ast:Pump ;
                    ast:pumpGpioPin ?pumpGpioPin ;
                    ast:pumpId ?pumpId .
                FILTER NOT EXISTS {
                    ?y a prog:Pump ;
                        prog:Pump_pumpGpioPin ?pumpGpioPin ;
                        prog:Pump_pumpId ?pumpId .
                }
            }");

        if newPumps == null then print("RECONFIG> No new pumps"); else
            print("RECONFIG> New Pump(s) detected: repairing the model");

            Int newPumpsLength = newPumps.length();
            i = 0;
            while i < newPumpsLength do
                Pump newPump = newPumps.get(i);

                print("RECONFIG> New pump detected: ");
                print("          Pump Id: " ++ newPump.pumpId);
                print("          Pump Gpio Pin: " ++ intToString(newPump.pumpGpioPin));
                i = i + 1;
            end

            print("RECONFIG> Pump(s) added");
        end

        /**
         *  Check for defects in the pumps
         */
        List<PumpDefect> changedPumps = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT ?obj ?pumpGpioPinNew
            WHERE {
                ?obj a prog:Pump ;
                    prog:Pump_pumpId ?pumpId ;
                    prog:Pump_pumpGpioPin ?pumpGpioPin .
                ?y rdf:type ast:Pump ;
                    ast:pumpId ?pumpId ;
                    ast:pumpGpioPin ?pumpGpioPinNew .
                FILTER(?pumpGpioPin != ?pumpGpioPinNew)
            }");

        if changedPumps == null then print("RECONFIG> No changed pumps"); else
            print("RECONFIG> Changed Pump(s) detected: repairing the model");

            Int changedPumpsLength = changedPumps.length();
            i = 0;
            while i < changedPumpsLength do
                PumpDefect pump = changedPumps.get(i);

                Pump changedPump = pump.obj;
                Int pumpGpioPinNew = pump.pumpGpioPinNew;

                print("RECONFIG> Changed pump to adjust: " ++ changedPump.pumpId);
                print("          Old GPIO pin: " ++ intToString(changedPump.pumpGpioPin));
                print("          New GPIO pin: " ++ intToString(pumpGpioPinNew));

                changedPump.pumpGpioPin = pumpGpioPinNew;
                
                i = i + 1;
            end

            print("RECONFIG> Pump(s) changed");
        end

        /**
         *  Destroy pumps that are not in the asset model
         */
        List<Pump> wrongPumps = access("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj
            WHERE {
                ?obj a prog:Pump ;
                    prog:Pump_pumpGpioPin ?pumpGpioPin ;
                    prog:Pump_pumpId ?pumpId .
                FILTER NOT EXISTS {
                    ?x rdf:type ast:Pump ;
                        ast:pumpGpioPin ?pumpGpioPin ;
                        ast:pumpId ?pumpId .
                }
            }");

        if wrongPumps == null then print("RECONFIG> No misconfigured pumps"); else
            print("RECONFIG> Misconfigured Pump(s) detected: repairing the model");

            Int wrongPumpsLength = wrongPumps.length();
            i = 0;
            while i < wrongPumpsLength do
                Pump wrongPump = wrongPumps.get(i);

                print("RECONFIG> Misconfigured pump to remove: " ++ wrongPump.pumpId);

                destroy(wrongPump);
                
                i = i + 1;
            end

            destroy(wrongPumps);

            print("RECONFIG> Pump(s) removed");
        end
    end

    /**
     *  Method invoked to reconfigure plants. It will add plants that are not
     *  in the program model and destroy plants that are not in the asset model.
     *
     *  @method reconfigurePlants
     */
    Unit reconfigurePlants()
        print("RECONFIG> Reconfiguring the plants");
        Int i = 0;

        /**
         *  Add plants that are not in the program model
         */
        List<Plant> newPlants = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT ?plantId ?plantType ?idealMoisture
            WHERE {
                ?x rdf:type ast:Plant ;
                    ast:plantId ?plantId ;
                    ast:plantType ?plantType ;
                    ast:idealMoisture ?idealMoisture .
                FILTER NOT EXISTS {
                    ?y a prog:Plant ;
                        prog:Plant_plantId ?plantId ;
                        prog:Plant_plantType ?plantType .
                }
            }");


        if newPlants == null then print("RECONFIG> No new plants"); else
            print("RECONFIG> New Plant(s) detected: repairing the model");

            Int newPlantsLength = newPlants.length();
            i = 0;
            while i < newPlantsLength do
                Plant newPlant = newPlants.get(i);

                print("RECONFIG> New plant detected: ");
                print("          Plant Id: " ++ newPlant.plantId);
                print("          Ideal Moisture: " ++ doubleToString(newPlant.idealMoisture));
                print("          Plant Type: " ++ newPlant.plantType);

                i = i + 1;
            end

            print("RECONFIG> Plant(s) added");
        end

        Plant p = new Plant("5", 50.0, "tomato", "good");
        Plant p2 = new Plant("2", 80.0, "Basilicum", "good");

        List<PlantDefect> changedPlants = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT ?obj ?idealMoistureNew
            WHERE {
                ?obj a prog:Plant ;
                    prog:Plant_plantId ?plantId ;
                    prog:Plant_idealMoisture ?idealMoisture ;
                    prog:Plant_plantType ?plantType .
                ?y rdf:type ast:Plant ;
                    ast:plantId ?plantId ;
                    ast:idealMoisture ?idealMoistureNew ;
                    ast:plantType ?plantType .
                FILTER(?idealMoisture != ?idealMoistureNew)
            }");

        if changedPlants == null then print("RECONFIG> No changed plants"); else
            print("RECONFIG> Changed Plant(s) detected: repairing the model");

            Int changedPlantsLength = changedPlants.length();
            i = 0;
            while i < changedPlantsLength do
                PlantDefect moist = changedPlants.get(i);

                Plant changedPlant = moist.obj;
                Double idealMoistureNew = moist.idealMoistureNew;
                // Plant changedPlant = changedPlants.get(i);

                print("RECONFIG> Changed plant to adjust: " ++ changedPlant.plantId ++ ", " ++ changedPlant.plantType);
                print("          Old ideal moisture: " ++ doubleToString(changedPlant.idealMoisture));
                print("          New ideal moisture: " ++ doubleToString(idealMoistureNew));

                changedPlant.idealMoisture = idealMoistureNew;
                
                i = i + 1;
            end

            print("RECONFIG> Plant(s) changed");
        end

        /**
         *  Destroy plants that are not in the asset model
         */
        List<Plant> wrongPlants = access("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj
            WHERE {
                ?obj a prog:Plant ;
                    prog:Plant_plantId ?plantId ;
                    prog:Plant_plantType ?plantType .
                FILTER NOT EXISTS {
                    ?y rdf:type ast:Plant ;
                        ast:plantId ?plantId ;
                        ast:plantType ?plantType .
                }
            }");

        if wrongPlants == null then print("RECONFIG> No misconfigured plants"); else
            print("RECONFIG> Misconfigured Plant(s) detected: repairing the model");

            Int wrongPlantsLength = wrongPlants.length();
            i = 0;
            while i < wrongPlantsLength do
                Plant wrongPlant = wrongPlants.get(i);

                print("RECONFIG> Misconfigured plant to remove: ");
                print("          Plant Id: " ++ wrongPlant.plantId);
                print("          Ideal Moisture: " ++ doubleToString(wrongPlant.idealMoisture));
                print("          Plant Type: " ++ wrongPlant.plantType);
                
                destroy(wrongPlant);
                
                i = i + 1;
            end

            destroy(wrongPlants);

            print("RECONFIG> Plant(s) removed");
        end
    end

    /**
     *  Method to check if the shelf of the Pot has changed
     *
     *  @method checkShelfChanged
     */
    Unit checkShelfChanged()
        Int i = 0;
        /**
         *  Check for defects in the pots
         */
        List<PotDefectShelf> changedPots = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj ?shelfFloorNew
            WHERE {
                ?obj a prog:Pot ;
                    prog:Pot_shelfFloor ?shelfFloor ;
                    prog:Pot_potPosition ?potPosition ;
                    prog:Pot_pumpId ?pumpId ;
                    prog:Pot_plantId ?plantId .
                ?y rdf:type ast:Pot ;
                    ast:shelfFloor ?shelfFloorNew ;
                    ast:potPosition ?potPosition ;
                    ast:wateredBy ?pump ;
                    ast:hasPlant ?plant .
                ?pump rdf:type ast:Pump ;
                    ast:pumpId ?pumpId .
                ?plant rdf:type ast:Plant ;
                    ast:plantId ?plantId .
                FILTER(?shelfFloor != ?shelfFloorNew)
            }");

        if changedPots == null then print("RECONFIG> No shelf changed on pots"); else
            print("RECONFIG> Changed Pot(s) detected: repairing the model");

            Int changedPotsLength = changedPots.length();
            i = 0;
            while i < changedPotsLength do
                PotDefectShelf pot = changedPots.get(i);

                Pot changedPot = pot.obj;
                String shelfFloorNew = pot.shelfFloorNew;

                print("RECONFIG> Changed pot to adjust: ");
                print("          Old Shelf Floor: " ++ changedPot.shelfFloor);
                print("          New Shelf Floor: " ++ shelfFloorNew);

                changedPot.shelfFloor = shelfFloorNew;
                
                i = i + 1;
            end

            print("RECONFIG> Pot(s) changed");
        end
    end

    /**
     *  Method to check if the position of the Pot has changed
     *
     *  @method checkPositionChanged
     */
    Unit checkPositionChanged()
        Int i = 0;

        List<PotDefectPosition> changedPots = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj ?potPositionNew
            WHERE {
                ?obj a prog:Pot ;
                    prog:Pot_shelfFloor ?shelfFloor ;
                    prog:Pot_potPosition ?potPosition ;
                    prog:Pot_pumpId ?pumpId ;
                    prog:Pot_plantId ?plantId .
                ?y rdf:type ast:Pot ;
                    ast:shelfFloor ?shelfFloor ;
                    ast:potPosition ?potPositionNew ;
                    ast:wateredBy ?pump ;
                    ast:hasPlant ?plant .
                ?pump rdf:type ast:Pump ;
                    ast:pumpId ?pumpId .
                ?plant rdf:type ast:Plant ;
                    ast:plantId ?plantId .
                FILTER(?potPosition != ?potPositionNew)
            }");

        if changedPots == null then print("RECONFIG> No position changed on pots"); else
            print("RECONFIG> Changed Pot(s) detected: repairing the model");

            Int changedPotsLength = changedPots.length();
            i = 0;
            while i < changedPotsLength do
                PotDefectPosition pot = changedPots.get(i);

                Pot changedPot = pot.obj;
                String potPositionNew = pot.potPositionNew;

                print("RECONFIG> Changed pot to adjust: ");
                print("          Old Pot Position: " ++ changedPot.potPosition);
                print("          New Pot Position: " ++ potPositionNew);

                changedPot.potPosition = potPositionNew;
                
                i = i + 1;
            end

            print("RECONFIG> Pot(s) changed");
        end
    end

    /**
     *  Method to check if the pump of the Pot has changed
     *
     *  @method checkPumpChanged
     */
    Unit checkPumpChanged()
        Int i = 0;

        List<PotDefectPump> changedPots = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj ?pumpIdNew
            WHERE {
                ?obj a prog:Pot ;
                    prog:Pot_shelfFloor ?shelfFloor ;
                    prog:Pot_potPosition ?potPosition ;
                    prog:Pot_pumpId ?pumpId ;
                    prog:Pot_plantId ?plantId .
                ?y rdf:type ast:Pot ;
                    ast:shelfFloor ?shelfFloor ;
                    ast:potPosition ?potPosition ;
                    ast:wateredBy ?pump ;
                    ast:hasPlant ?plant .
                ?pump rdf:type ast:Pump ;
                    ast:pumpId ?pumpIdNew .
                ?plant rdf:type ast:Plant ;
                    ast:plantId ?plantId .
                FILTER(?pumpId != ?pumpIdNew)
            }");

        if changedPots == null then print("RECONFIG> No pump changed on pots"); else
            print("RECONFIG> Changed Pot(s) detected: repairing the model");

            Int changedPotsLength = changedPots.length();
            i = 0;
            while i < changedPotsLength do
                PotDefectPump pot = changedPots.get(i);

                Pot changedPot = pot.obj;
                String pumpIdNew = pot.pumpIdNew;

                print("RECONFIG> Changed pot to adjust: ");
                print("          Old Pump Id: " ++ changedPot.pumpId);
                print("          New Pump Id: " ++ pumpIdNew);

                changedPot.pumpId = pumpIdNew;
                
                i = i + 1;
            end

            print("RECONFIG> Pot(s) changed");
        end
    end

    /**
     *  Method to check if the plant of the Pot has changed
     *
     *  @method checkPlantChanged
     */
    Unit checkPlantChanged()
        Int i = 0;
        
        List<PotDefectPlant> changedPots = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj ?plantIdNew
            WHERE {
                ?obj a prog:Pot ;
                    prog:Pot_shelfFloor ?shelfFloor ;
                    prog:Pot_potPosition ?potPosition ;
                    prog:Pot_pumpId ?pumpId ;
                    prog:Pot_plantId ?plantId .
                ?y rdf:type ast:Pot ;
                    ast:shelfFloor ?shelfFloor ;
                    ast:potPosition ?potPosition ;
                    ast:wateredBy ?pump ;
                    ast:hasPlant ?plant .
                ?pump rdf:type ast:Pump ;
                    ast:pumpId ?pumpId .
                ?plant rdf:type ast:Plant ;
                    ast:plantId ?plantIdNew .
                FILTER(?plantId != ?plantIdNew)
            }");

        if changedPots == null then print("RECONFIG> No plant changed on pots"); else
            print("RECONFIG> Changed Pot(s) detected: repairing the model");

            Int changedPotsLength = changedPots.length();
            i = 0;
            while i < changedPotsLength do
                PotDefectPlant pot = changedPots.get(i);

                Pot changedPot = pot.obj;
                String plantIdNew = pot.plantIdNew;

                print("RECONFIG> Changed pot to adjust: ");
                print("          Old Plant Id: " ++ changedPot.plantId);
                print("          New Plant Id: " ++ plantIdNew);

                changedPot.plantId = plantIdNew;
                
                i = i + 1;
            end

            print("RECONFIG> Pot(s) changed");
        end
    end

    /**
     *  Method invoked to reconfigure pots. It will add pots that are not
     *  in the program model and destroy pots that are not in the asset model.
     *
     *  @method reconfigurePots
     */
    Unit reconfigurePots()
        print("RECONFIG> Reconfiguring the pots");
        Int i = 0;
        
        /**
         *  Add pots that are not in the program model
         */
        List<Pot> newPots = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT ?shelfFloor ?potPosition ?pumpId ?plantId
            WHERE {
                ?x rdf:type ast:Pot ; 
                    ast:shelfFloor ?shelfFloor ;
                    ast:potPosition ?potPosition ;
                    ast:wateredBy ?pump ;
                    ast:hasPlant ?plant .
                ?pump rdf:type ast:Pump ;
                    ast:pumpId ?pumpId .
                ?plant rdf:type ast:Plant ;
                    ast:plantId ?plantId .
                FILTER NOT EXISTS {
                    ?y a prog:Pot ; 
                        prog:Pot_helfFloor ?shelfFloor ;
                        prog:Pot_potPosition ?potPosition ;
                        prog:Pot_pumpId ?pumpId ;
                        prog:Pot_plantId ?plantId .
                }
            }");


        if newPots == null then print("RECONFIG> No new pots"); else
            print("RECONFIG> New Pot(s) detected: repairing the model");

            Int newPotsLength = newPots.length();
            i = 0;
            while i < newPotsLength do
                Pot newPot = newPots.get(i);
                print("RECONFIG> New pot detected: ");
                print("          Shelf Floor: " ++ newPot.shelfFloor);
                print("          Pump Id: " ++ newPot.pumpId);
                print("          Plant Id: " ++ newPot.plantId);
                i = i + 1;
            end

            print("RECONFIG> Pot(s) added");
        end

        /**
         *  Check for defects in the pots
         */
        print("RECONFIG> Checking for defects in the Pot(s)");
        this.checkShelfChanged();
        this.checkPositionChanged();
        this.checkPumpChanged();
        this.checkPlantChanged();
        print("RECONFIG> Defects checked for Pot(s)");

        /**
         *  Destroy pots that are not in the asset model
         */
        List<Pot> wrongPots = access("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj
            WHERE {
                ?obj a prog:Pot ;
                    prog:Pot_shelfFloor ?shelfFloor ;
                    prog:Pot_potPosition ?potPosition .
                FILTER NOT EXISTS {
                    ?y rdf:type ast:Pot ; 
                        ast:shelfFloor ?shelfFloor ;
                        ast:potPosition ?potPosition .
                }
            }");

        if wrongPots == null then print("RECONFIG> No misconfigured pots"); else
            print("RECONFIG> Misconfigured Pot(s) detected: repairing the model");

            Int wrongPotsLength = wrongPots.length();
            i = 0;
            while i < wrongPotsLength do
                Pot wrongPot = wrongPots.get(i);

                print("RECONFIG> Misconfigured pot to remove: ");
                print("          ShelfFloor: " ++ wrongPot.shelfFloor); 
                print("          Pot Position: " ++ wrongPot.potPosition);
                
                destroy(wrongPot);
                
                i = i + 1;
            end

            destroy(wrongPots);

            print("RECONFIG> Pot(s) removed");
        end
    end

    /**
     *  Method invoked to reconfigure health state. It will add those that are not
     *  in the program model and destroy health states that are not in the asset model.
     *
     *  @method reconfigureHealthStates
     */
    Unit reconfigureHealthStates()
        print("RECONFIG> Reconfiguring the health states");
        Int i = 0;

        /**
         *  Add health states that are not in the program model
         */
        List<HealthState> newHealthStates = construct("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT ?name ?maxNdvi ?minNdvi
            WHERE {
                ?healthState rdf:type ast:HealthState ;
                    ast:name ?name ;
                    ast:maxNdvi ?maxNdvi ;
                    ast:minNdvi ?minNdvi .
                FILTER NOT EXISTS {
                    ?y a prog:HealthState ;
                        prog:HealthState_name ?name ;
                        prog:HealthState_maxNdvi ?maxNdvi ;
                        prog:HealthState_minNdvi ?minNdvi .
                }
            }");

        if newHealthStates == null then print("RECONFIG> No new health states"); else
            print("RECONFIG> New Health State(s) detected: repairing the model");

            Int newHealthStatesLength = newHealthStates.length();
            i = 0;
            while i < newHealthStatesLength do
                HealthState newHealthState = newHealthStates.get(i);

                print("RECONFIG> New Health State detected: ");
                print("          Name: " ++ newHealthState.name);
                print("          Max Ndvi: " ++ doubleToString(newHealthState.maxNdvi));
                print("          Min Ndvi: " ++ doubleToString(newHealthState.minNdvi));

                i = i + 1;
            end

            print("RECONFIG> Health State(s) added");
        end

        /**
         *  Destroy health states that are not in the asset model
         */
        List<HealthState> wrongHealthStates = access("
            PREFIX ast: <http://www.smolang.org/grennhouseDT#>
            SELECT DISTINCT ?obj
            WHERE {
                ?obj a prog:HealthState ;
                    prog:HealthState_name ?name ;
                    prog:HealthState_maxNdvi ?maxNdvi ;
                    prog:HealthState_minNdvi ?minNdvi .
                FILTER NOT EXISTS {
                    ?y rdf:type ast:HealthState ;
                        ast:name ?name ;
                        ast:maxNdvi ?maxNdvi ;
                        ast:minNdvi ?minNdvi .
                }
            }");

        if wrongHealthStates == null then print("RECONFIG> No misconfigured health states"); else
            print("RECONFIG> Misconfigured Health State(s) detected: repairing the model");

            Int wrongHealthStatesLength = wrongHealthStates.length();
            i = 0;
            while i < wrongHealthStatesLength do
                HealthState wrongHealthState = wrongHealthStates.get(i);

                print("RECONFIG> Misconfigured plant to remove: ");
                print("          Name: " ++ wrongHealthState.name);
                print("          Max Ndvi: " ++ doubleToString(wrongHealthState.maxNdvi));
                print("          Min Ndvi: " ++ doubleToString(wrongHealthState.minNdvi));
                
                destroy(wrongHealthState);
                
                i = i + 1;
            end

            destroy(wrongHealthStates);
        end
    end

    Unit reconfigure()
        print("RECONFIG> Reconfiguring the asset model...");

        // Calling the reconfiguration methods
        this.reconfigurePump();
        this.reconfigurePlants();
        this.reconfigurePots();
        this.reconfigureHealthStates();

        print("RECONFIG> Reconfiguring DONE...");
    end

    Unit decision()
        this.removePlantToWater();
        print("BEHAVIOUR> Behavioural reconfiguration of the asset model...");
        Int i = 0;
        Int j = 0;
        // List of plants (ids of plants) that need to be watered
        // List<PlantToWater> plantsToWater = null;

        List<Plant> plants = access("
            SELECT DISTINCT ?obj
            WHERE {
                ?obj a prog:Plant ;
                    prog:Plant_plantId ?plantId ;
                    prog:Plant_idealMoisture ?idealMoisture .
            }");

        if plants != null then
            Int plantsLength = plants.length();

            i = 0;
            while i < plantsLength do
                Plant plant = plants.get(i);
                
                if plant != null then
                    Double plantMoisture = plant.getPotMoisture();

                    if (plantMoisture < plant.idealMoisture) then
                        print("BEHAVIOUR> Plant that has to be watered: " ++ plant.plantId);

                        List<Pump> pumpsThatWater = access("
                            SELECT ?obj
                            WHERE {
                            ?obj a prog:Pump ;
                                    prog:Pump_pumpId ?pumpId ;
                                    prog:Pump_pumpGpioPin ?pumpGpioPin .
                            ?pot a prog:Pot ;
                                    prog:Pot_plantId %1 ;
                                    prog:Pot_pumpId ?pumpId .
                            }
                        ", plant.plantId);

                        if pumpsThatWater != null then
                            Pump pumpThatWater = pumpsThatWater.get(0);

                            PlantToWater plantToWater = new PlantToWater(plant.plantId, pumpThatWater.pumpGpioPin, pumpThatWater.pumpId);
                            this.plantsToWater = new List<PlantToWater>(plantToWater, this.plantsToWater);

                            print("BEHAVIOUR> pump id: " ++ pumpThatWater.pumpId);
                        else
                            print("Error in creating an object");
                        end
                    end

                    List<HealthState> healthStates = access("
                        SELECT DISTINCT ?obj
                        WHERE {
                            ?obj a prog:HealthState ;
                                prog:HealthState_healthStateId ?healthStateId ;
                                prog:HealthState_healthStateName ?healthStateName .
                        }");
                
                    if healthStates != null then
                        Int healthStatesLength = healthStates.length();
                        j = 0;
                        while j < healthStatesLength do
                            HealthState healthState = healthStates.get(j);
                            Double plantNdvi = plant.getNdvi();

                            Double healthStateMinNdvi = healthState.minNdvi;
                            Double healthStateMaxNdvi = healthState.maxNdvi;

                            Boolean minOk = plantNdvi >= healthStateMinNdvi;
                            Boolean maxOk = plantNdvi <= healthStateMaxNdvi;

                            if minOk then
                                if maxOk then
                                    print("BEHAVIOUR> Plant in good health");
                                    plant.healthState = healthState.name;
                                end
                            end
                            
                            j = j + 1;
                        end
                    end
                end
                
                i = i + 1;
            end
        end

        print("BEHAVIOUR> Behavioural reconfiguration DONE...");
    end
end

main
    AssetModel assetModel = new AssetModel(null);
    assetModel.reconfigure();
    assetModel.decision();

    breakpoint;
end
